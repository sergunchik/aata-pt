<?xml version="1.0" encoding="UTF-8" ?>

<!-- This file is part of the book                 -->
<!--                                               -->
<!--   Abstract Algebra: Theory and Applications   -->
<!--                                               -->
<!-- Copyright (C) 2010-2014  Robert A. Beezer     -->
<!-- See the file COPYING for copying conditions.  -->

<section xml:id="actions-sage">
	<title>Sage</title>

	<introduction>
		<p>Los grupos se pueden presentar de diversas formas, tales como conjuntos de permutaciones, como conjuntos de matrices o como conjuntos de símbolos abstractos relacionados por ciertas reglas (<q>presentaciones</q>) y en muchas otras formas más.  Nos hemos concentrado en grupos de permutaciones por su tangibilidad, con elementos escritos como funciones, y por lo bien implementados que están en Sage.  Las acciones de grupo son de gran interés cuando el conjunto en el que se actúa es el grupo mismo, y la acción de grupos figura de forma prominente en las demostraciones de  los principales teoremas del próximo capítulo.  Pero, cada vez que tenemos una acción de un grupo en un conjunto, podemos pensar el grupo como un grupo de permutaciones en los elementos del conjunto.  Por esto los grupos de permutaciones forman un área de teoría de grupos de interés independiente, con sus propias definiciones y teoremas.</p>

		<p>Describiremos los comandos de Sage aplicables cuando un acción de grupo aparece naturalmente vía conjugación, y luego pasaremos a la situación más general.</p>

		<todo>Construct a general n beads, m colors enumeration example (any of this in Sage already?)</todo>

	</introduction>

	<subsection>
		<title>Conjugación como Acción de Grupo</title>

		<p>Podemos creer que debemos ser cuidadosos con la forma en que Sage define la conjugación (<m>gxg^{-1}</m> versus <m>g^{-1}xg</m>) y la diferencia entre Sage y el texto sobre el orden de los productos.  Pero, si nos fijamos en la definición de centro y de subgrupo centralizador podemos notar que cualquier diferencia de orden es irrelevante. (Por algo no tenemos conjugación izquierda y derecha como conceptos) A continuación los comandos de  acción de grupos para la acción particular de conjugar elementos del grupo.</p>

		<p>Sage tiene un método <c>.center()</c> que entrega el subgrupo de los puntos fijos.  El método <c>.centralizer(g)</c>, entrega un subgrupo que es el estabilizador del elemento <c>g</c>.  Finalmente, las órbitas están dadas por clases de conjugación, pero Sage no nos inundará con las clases de conjugación completas y en su lugar nos entrega una lista que contiene un elemento por clase de conjugación, es decir una lista de representantes, por medio del método <c>.conjugacy_classes_representatives()</c>.  Podemos reconstruir manualmente una clase de conjugación a partir de un elemento, como haremos en el ejemplo de abajo.</p>

		<p>Acá los comandos de arriba en acción.  Notemos que un grupo abeliano sería una mala elección para este ejemplo.</p>

		<sage>
		<input>
		D = DihedralGroup(8)
		C = D.center(); C
		</input>
		<output>
		Subgroup of (Dihedral group of order 16 as a permutation group)
		generated by [(1,5)(2,6)(3,7)(4,8)]
		</output>
		</sage>

		<sage>
		<input>
		C.list()
		</input>
		<output>
		[(), (1,5)(2,6)(3,7)(4,8)]
		</output>
		</sage>

		<sage>
		<input>
		a = D("(1,2)(3,8)(4,7)(5,6)")
		C1 = D.centralizer(a); C1.list()
		</input>
		<output>
		[(), (1,2)(3,8)(4,7)(5,6), (1,5)(2,6)(3,7)(4,8), (1,6)(2,5)(3,4)(7,8)]
		</output>
		</sage>

		<sage>
		<input>
		b = D("(1,2,3,4,5,6,7,8)")
		C2 = D.centralizer(b); C2.order()
		</input>
		<output>
		8
		</output>
		</sage>

		<sage>
		<input>
		CCR = D.conjugacy_classes_representatives(); CCR
		</input>
		<output>
		[(), (2,8)(3,7)(4,6), (1,2)(3,8)(4,7)(5,6), (1,2,3,4,5,6,7,8),
		 (1,3,5,7)(2,4,6,8), (1,4,7,2,5,8,3,6), (1,5)(2,6)(3,7)(4,8)]
		</output>
		</sage>

		<sage>
		<input>
		r = CCR[2]; r
		</input>
		<output>
		(1,2)(3,8)(4,7)(5,6)
		</output>
		</sage>

		<sage>
		<input>
		conj = []
		x = [conj.append(g^-1*r*g) for g in D if not g^-1*r*g in conj]
		conj
		</input>
		<output>
        [(1,2)(3,8)(4,7)(5,6), (1,4)(2,3)(5,8)(6,7),
         (1,6)(2,5)(3,4)(7,8), (1,8)(2,7)(3,6)(4,5)]
		</output>
		</sage>

		<p>Note que en la clase de conjugación construida todos los elementos tienen la misma estructura de ciclos, lo que no es accidental.  Note además que <c>rep</c> y <c>a</c> son el mismo elemento, y que el producto del orden del centralizador (<m>4</m>) por el tamaño de la clase (<m>4</m>) es igual al orden del grupo (<m>16</m>), lo que es una variante de la conclusión del Teorema<nbsp /><xref ref="theorem-orbit" />.</p>

		<p>Compruebe que la siguiente es una ejemplificación de la ecuación de clase en el caso especial de acción por conjugación, pero sería válida para cualquier grupo, en lugar de <c>D</c>.</p>

		<sage>
		<input>
		sizes = [D.order()/D.centralizer(g).order()
		             for g in D.conjugacy_classes_representatives()]
		sizes
		</input>
		<output>
		[1, 4, 4, 2, 2, 2, 1]
		</output>
		</sage>

		<sage>
		<input>
		D.order() == sum(sizes)
		</input>
		<output>
		True
		</output>
		</sage>

	</subsection>

	<subsection>
		<title>Automorfismos de un Grafo</title>

		<p>Como ya mencionamos, la acción de grupo puede ser aún más interesante cuando el conjunto en el que se actúa es diferente al grupo mismo.  Una clase de ejemplos es el grupo de simetrías de un sólido geométrico, donde los objetos en el conjunto son los vértices del sólido, o quizás otro aspecto de éste como aristas, caras o diagonales.  En este caso, el grupo está formado por el conjunto de aquellas permutaciones que mueven el sólido pero lo dejan ocupando el mismo espacio que antes del movimiento (<q>movimientos rígidos</q>).</p>

		<p>En esta sección examinaremos algo muy similar.  Un <term>grafo</term> es un objeto matemático, que consiste de vértices y aristas, pero la única estructura es si un par de vértices dado está o no conectado por una arista.  El grupo consiste de  aquellas permutaciones de los vértices que preservan la estructura, es decir, permutaciones de vértices que lleva aristas en aristas y no-aristas en no-aristas.  Es muy similar a un grupo de simetría, pero no hay noción alguna de relación geométrica que se preserve.</p>

		<p>Acá hay un ejemplo.  Deberá ejecutar la primera celda para definir el grafo y obtener una representación gráfica.</p>

		<sage doctest="not tested">
		<input>
		Q = graphs.CubeGraph(3)
		Q.plot(layout='spring')
		</input>
		</sage>

		<sage>
		<input>
		A = Q.automorphism_group()
		A.order()
		</input>
		<output>
		48
		</output>
		</sage>

		<p>Se debiera ver como los vértices y aristas de un cubo, pero puede que no se vea del todo regular, lo que está bien, pues la geometría no es relevante.  Los vértices están etiquetados con cadenas de tres dígitos binarios, <m>0</m> o <m>1</m>, y dos vétrices están conectados por una arista si sus etiquetas diferen en exactamente una posición.  Podríamos esperar que el grupo de simetría tuviera orden <m>24</m>, en lugar de orden <m>48</m>, dado su parecido a un cubo (tanto en apariencia como en nombre).  Sin embargo, al no estar restringidos a movimientos rígidos, tenemos nuevas permutaciones que preservan las aristas.  Una en particular es el intercambio de dos <q>caras opuestas.</q>  Localice los dos <m>4</m>-ciclos opuestos entre sí, listados en el mismo orden:  <m>000, 010, 110, 100</m> y <m>001, 011, 111, 101</m>.  Notemos que cada ciclo se ve muy similar, pero los vértices de uno terminan en 0 y los del otro en 1.</p>

		<p>Podemos crear explícitamente la permutación que intercambia estas dos caras opuestas, usando una versión textual de la permutación en notación de ciclos.</p>

		<sage>
		<input>
		a = A("('000','001')('010','011')('110','111')('100','101')")
		a in A
		</input>
		<output>
		True
		</output>
		</sage>

		<p>Podemos usar este grupo para ilustrar los comandos de Sage relevantes para la acción de grupos.</p>

		<sage>
		<input>
		A.orbits()
		</input>
		<output>
		[['000', '001', '010', '100', '011', '101', '110', '111']]
		</output>
		</sage>

		<p>Esta acción tiene solo una (gran) órbita.  Esto quiere decir que cualquier vértices es <q>como</q> cualquier otro.  Cuando un grupo de permutaciones se comporta de esta manera, decimos que el grupo es  <term>transitivo</term>.</p>

		<sage>
		<input>
		A.is_transitive()
		</input>
		<output>
		True
		</output>
		</sage>

		<p>Si cada vértice es <q>igual</q> podemos calcular el estabilizador de cualquier vértice, pues todos serán isomorfos.  Como el vértice <m>000</m> es el más simple en algún sentido, calcularemos su estabilizador.</p>

		<sage>
		<input>
		S = A.stabilizer('000')
		S.list()
		</input>
		<output>
        [(),
         ('001','100','010')('011','101','110'),
         ('010','100')('011','101'),
         ('001','010','100')('011','110','101'),
         ('001','100')('011','110'),
         ('001','010')('101','110')]
		</output>
		</sage>

		<p>Que <c>S</c> tenga <m>6</m> elementos no es una sorpresa, pues el grupo tiene orden <m>48</m> y el tamaño de la única órbita es <m>8</m>.  Pero podemos dar un paso más.  Los tres vértices del grafo adyacentes directamente con <m>000</m> son <m>100</m>, <m>010</m>, <m>001</m>.  Cualquier automorfismo del grafo que  fije <m>000</m> debe entonces permutar los tres vértices adyacentes.  Hay <m>3!=6</m> posibles maneras de hacer esto, y podemos verificar que cada una aparece en una de los seis elementos del estabilizador.  Así podemos entender un grupo transitivo considerando el estabilizador que es más pequeño, y en este caso vemos que cada elemento del estabilizador está determinado por como permuta a los vecinos del vértice estabilizado.</p>

		<p>Los grupos transitivos son tan inusuales como importantes.  En contraste, acá hay un grupo de automorfismos de un grafo que está lejos de ser transitivo (sin ser trivial).  Un camino es un grafo que tiene todos sus vértices en una línea.  Ejecute la primera  celda para ver un camino en <m>11</m> vértices.</p>

		<sage doctest="not tested">
		<input>
		P = graphs.PathGraph(11)
		P.plot()
		</input>
		</sage>

		<sage>
		<input>
		A = P.automorphism_group()
		A.list()
		</input>
		<output>
		[(), (0,10)(1,9)(2,8)(3,7)(4,6)]
		</output>
		</sage>

		<p>El grupo de automorfismos es la identidad (siempre) y una permutación de orden <m>2</m> que <q>da vuelta</q> el camino de un lado para el otro.  El grupo está lejos de ser transitivo y hay muchas órbitas.</p>

		<sage>
		<input>
		A.is_transitive()
		</input>
		<output>
		False
		</output>
		</sage>

		<sage>
		<input>
		A.orbits()
		</input>
		<output>
		[[0, 10], [1, 9], [2, 8], [3, 7], [4, 6], [5]]
		</output>
		</sage>

		<p>La mayoría de los estabilizadores es trivial, con una excepción.  Como subgrupos de un grupo de orden <m>2</m>, realmente no hay muchas opciones.</p>

		<sage>
		<input>
		A.stabilizer(2).list()
		</input>
		<output>
		[()]
		</output>
		</sage>

		<sage>
		<input>
		A.stabilizer(5).list()
		</input>
		<output>
		[(), (0,10)(1,9)(2,8)(3,7)(4,6)]
		</output>
		</sage>

		<p>¿Cómo habría sido diferente este ejemplo final de haber usado un camino en <m>10</m> vértices?</p>


	</subsection>
</section>